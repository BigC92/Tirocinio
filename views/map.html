<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <title></title>
</head>
<body style="overflow: hidden ">
<script src="javascripts/three.min.js"></script>
<script src="javascripts/csg.js"></script>
<script src="javascripts/ThreeCSG.js"></script>
<script src="javascripts/THREEx.keyboardstate.js"></script>
<script src="javascripts/OrbitControls.js"></script>
<script src="javascripts/THREEx.FullScreen.js"></script>
<script src="javascripts/THREEx.WindowResize.js"></script>
<script>
    var renderer, scene, camera;
    var geometry = new THREE.BoxGeometry(640, 640, 0.1);
    var controls, texture, material;
    var clock = new THREE.Clock();
    var c_lon, c_lat;
    var newC_lon, newC_lat;
    var keyboard = new THREEx.KeyboardState();
    var w = parseFloat("<%=width%>");
    var h = parseFloat("<%=height%>");
    var z = parseInt("<%=zoom%>");
    var plane, succPlane, prevPlane, supPlane, infPlane, zoomP;
    var auxPlane;

    init();
    animate();
    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
        camera.position.set(0,200,460);

        renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        THREEx.WindowResize(renderer, camera);
        THREEx.FullScreen.bindKey({charCode: 'm'.charCodeAt(0)});
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.noZoom = true;
        controls.noRotate = true;
        controls.noPan = true;
        c_lon = parseFloat("<%=c_lon%>");
        c_lat = parseFloat("<%=c_lat%>");

        texture = THREE.ImageUtils.loadTexture("/image/"+c_lat+"/"+ c_lon +"/"+z, {},
                function () {});
        texture.minFilter = THREE.LinearFilter;
        material = new THREE.MeshBasicMaterial({ map: texture, color: 0xffffff});
        plane = new THREE.Mesh(geometry, material);
        plane.rotation.x = -Math.PI/2;

        var aux = new THREE.BoxGeometry("<%=width%>", "<%=height%>", 0.1);
        var auxMesh = new THREE.Mesh(aux);
        var auxBSP = new ThreeBSP(auxMesh);

        var logical = new THREE.BoxGeometry(20000, 20000, 0.1);
        var logicalMesh = new THREE.Mesh(logical);
        var logicalBSP = new ThreeBSP(logicalMesh);

        var newPlaneBSP = logicalBSP.subtract(auxBSP);
        var newMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
        auxPlane = newPlaneBSP.toMesh(newMaterial);
        auxPlane.position.y = 0.5;
        auxPlane.rotation.x = -Math.PI/2;

        scene.add(auxPlane);
        scene.add(plane);
    }

    function approxLat(LAT){
        return (LAT+48.387946125)/132.89234375;
    }

//    Calcola il centro della tile superiore
    function supCenter(a){
        return (((170.1022*640)/(256*Math.pow(2,z)))+a);
    }

//    Calcola il centro della tile inferiore
    function infCenter(a){
        return (a-((170.1022*640)/(256*Math.pow(2,z))));
    }

//    Calcola il centro della tile a destra
    function succCenter(a){
        var c = ((360*640)/(256*Math.pow(2,z)))+a;
        if(c>180)
            c-=360;
        return c;
    }

//    Calcola il centro della tile a sinistra
    function prevCenter(a){
        var b = a-((360*640)/(256*Math.pow(2,z)));
        if(b<-180)
            b+=360;
        return b;
    }

    function animate()
    {
        requestAnimationFrame( animate );
        render();
        update();
    }

    function update()
    {
        var moveDistance = 1;
//        zoom up/down
        if(keyboard.pressed("W")){
            z += 1;
            if(z<=20) {

                var zoomedTexture = new THREE.ImageUtils.loadTexture("/image/" + c_lat + "/" + c_lon + "/" + z, {}, function () {
                });
                zoomedTexture.minFilter = THREE.LinearFilter;
                var zoomedMaterial = new THREE.MeshBasicMaterial({map: zoomedTexture, color: 0xffffff});
                zoomP = new THREE.Mesh(geometry, zoomedMaterial);
                zoomP.rotation.x = -Math.PI / 2;
                zoomP.positions = plane.positions;
                scene.remove(plane);
                scene.add(zoomP);
                plane = zoomP;
                zoomP = null;
            }
        }

        if(keyboard.pressed("S")){
            if(z>1) {
                z -= 1;
                var deZoomedText = new THREE.ImageUtils.loadTexture("/image/" + c_lat + "/" + c_lon + "/" + z, {}, function () {
                });
                deZoomedText.minFilter = THREE.LinearFilter;
                var deZoomedMat = new THREE.MeshBasicMaterial({map: deZoomedText, color: 0xffffff});
                zoomP = new THREE.Mesh(geometry, deZoomedMat);
                zoomP.rotation.x = -Math.PI / 2;
                zoomP.position = plane.position;
                scene.remove(plane);
                scene.add(zoomP);
                plane = zoomP;
                zoomP = null;
            }
        }

//        move forwards/backwards/left/right
        if ( keyboard.pressed("up") ){
            console.log("up");
            plane.position.z += moveDistance;
            newC_lat = supCenter(c_lat);
            while(plane.position.z > ((640 - h)/2)/2){
                    scene.remove(supPlane);
                    c_lat=newC_lat;
                    var supTexture = new THREE.ImageUtils.loadTexture("/image/"+c_lat+"/"+
                            c_lon+"/"+z,{}, function(){});
                    supTexture.minFilter = THREE.LinearFilter;
                    var supMaterial = new THREE.MeshBasicMaterial({map: supTexture, color: 0xffffff});
                    supPlane = new THREE.Mesh(geometry, supMaterial);
                    supPlane.rotation.x = -Math.PI/2;
                    supPlane.position.x = plane.position.x;
                    supPlane.position.z = plane.position.z-639*approxLat(c_lat);
                    console.log(approxLat(c_lat));
                    plane.position.y = -0.2;
                    scene.add(supPlane);
                    scene.remove(infPlane);
                    scene.remove(succPlane);
                    scene.remove(prevPlane);
                    infPlane=plane;
                    plane=supPlane;
                    supPlane=null;
                }
            if(infPlane!=null) infPlane.position.z +=moveDistance;
            if(supPlane!=null) supPlane.position.z += moveDistance;
            if(prevPlane!=null) prevPlane.position.z +=moveDistance;
            if(succPlane!=null) succPlane.position.z +=moveDistance;
            console.log(plane.position.z);
        }

        if ( keyboard.pressed("down") ) {
            console.log("down");
            console.log((-640 + h)/2);
            plane.position.z -= moveDistance;
            newC_lat = infCenter(c_lat);
            while(plane.position.z < ((h - 640)/2)/2){
                scene.remove(infPlane);
                c_lat=newC_lat;
                var infTexture = new THREE.ImageUtils.loadTexture("/image/"+c_lat+"/"+
                        c_lon+"/"+z,{}, function(){
                });
                infTexture.minFilter = THREE.LinearFilter;
                var infMaterial = new THREE.MeshBasicMaterial({map: infTexture, color: 0xffffff});
                infPlane = new THREE.Mesh(geometry, infMaterial);
                infPlane.rotation.x = -Math.PI/2;
                infPlane.position.x = plane.position.x;
                infPlane.position.z = plane.position.z+639*approxLat(c_lat);
                console.log(approxLat(c_lat));
                plane.position.y = -0.2;
                scene.add(infPlane);
                scene.remove(supPlane);
                scene.remove(succPlane);
                scene.remove(prevPlane);
                supPlane=plane;
                plane=infPlane;
                infPlane=null;
            }
            if(supPlane!=null) supPlane.position.z -=moveDistance;
            if(infPlane!=null) infPlane.position.z -=moveDistance;
            if(prevPlane!=null) prevPlane.position.z -=moveDistance;
            if(succPlane!=null) succPlane.position.z -=moveDistance;
        }

        if ( keyboard.pressed("left") ){
            console.log("left");
            plane.position.x += moveDistance;

            newC_lon=prevCenter(c_lon);
            while((plane.position.x > (((640 - w)/2)/2))) {
                scene.remove(prevPlane);
                c_lon=newC_lon;
                var prevTexture = new THREE.ImageUtils.loadTexture("/image/"+c_lat+"/"+
                        c_lon+"/"+z, {}, function () {
                });
                prevTexture.minFilter = THREE.LinearFilter;
                var prevMaterial = new THREE.MeshBasicMaterial({map: prevTexture, color: 0xffffff});
                prevPlane = new THREE.Mesh(geometry, prevMaterial);
                prevPlane.rotation.x = -Math.PI / 2;
                prevPlane.position.x = plane.position.x - 639;
                prevPlane.position.z = plane.position.z;
                scene.add(prevPlane);
                scene.remove(succPlane);
                scene.remove(supPlane);
                scene.remove(infPlane);
                succPlane=plane;
                plane=prevPlane;
                prevPlane=null;
            }
            if(succPlane!=null) succPlane.position.x += moveDistance;
            if(prevPlane!=null) prevPlane.position.x += moveDistance;
            if(infPlane!=null) infPlane.position.x += moveDistance;
            if(supPlane!=null) supPlane.position.x += moveDistance;

        }


        if ( keyboard.pressed("right") ) {
            console.log("right");
            newC_lon = succCenter(c_lon);

            if((plane.position.x >= (w-640)/2) || (newC_lon <= 180 && newC_lon >= -180)) {
                plane.position.x -= moveDistance;
            }

            console.log(plane.position.x);

            while((plane.position.x < ((-640 + w)/2)/2) && (newC_lon <= 180 && newC_lon >= -180)) {
                scene.remove(succPlane);
                c_lon=newC_lon;
                var succTexture = new THREE.ImageUtils.loadTexture("/image/"+c_lat+"/" +
                        c_lon + "/"+z, {}, function () {
                });
                succTexture.minFilter = THREE.LinearFilter;
                var succMaterial = new THREE.MeshBasicMaterial({map: succTexture, color: 0xffffff});
                succPlane = new THREE.Mesh(geometry, succMaterial);
                succPlane.rotation.x = -Math.PI / 2;
                succPlane.position.x = plane.position.x + 639;
                succPlane.position.z = plane.position.z;
                scene.add(succPlane);
                scene.remove(prevPlane);
                prevPlane=plane;
                plane=succPlane;
                succPlane=null;
            }
            if(prevPlane!=null) prevPlane.position.x -= moveDistance;
            if(succPlane!=null) succPlane.position.x -= moveDistance;
            if(supPlane!=null) supPlane.position.x -= moveDistance;
            if(infPlane!=null) infPlane.position.x -= moveDistance;
        }

        controls.update();
    }

    function render()
    {
        renderer.render( scene, camera );
    }

</script>
</body>
</html>